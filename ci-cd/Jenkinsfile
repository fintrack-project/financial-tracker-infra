pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'quay.io/johnkim1'
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        SERVICES = 'frontend,backend,etl'
        // Get branch name from git command, fallback to env.BRANCH_NAME
        BRANCH_NAME = sh(script: 'git rev-parse --abbrev-ref HEAD || echo $BRANCH_NAME', returnStdout: true).trim()
        BASE_COMPOSE = 'docker-compose.yml'
        ENV_COMPOSE = "docker-compose.${params.BUILD_ENVIRONMENT}.yml"
        ENV_FILE = ".env.${params.BUILD_ENVIRONMENT}"
        // Add timeout for health checks
        HEALTH_CHECK_TIMEOUT = '300' // 5 minutes
        HEALTH_CHECK_INTERVAL = '10' // 10 seconds
        // Service repositories (only for services we build)
        FRONTEND_REPO = 'https://github.com/fintrack-project/financial-tracker-frontend'
        BACKEND_REPO = 'https://github.com/fintrack-project/financial-tracker-backend'
        ETL_REPO = 'https://github.com/fintrack-project/financial-tracker-etl'
    }

    parameters {
        choice(
            name: 'BUILD_ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Select environment to build for'
        )
        string(
            name: 'VERSION_MAJOR',
            defaultValue: '1',
            description: 'Major version number'
        )
        string(
            name: 'VERSION_MINOR',
            defaultValue: '0',
            description: 'Minor version number'
        )
        string(
            name: 'VERSION_PATCH',
            defaultValue: '0',
            description: 'Patch version number'
        )
        choice(
            name: 'SERVICES_TO_BUILD',
            choices: ['all', 'frontend', 'backend', 'etl'],
            description: 'Select services to build'
        )
        choice(
            name: 'PUSH_IMAGES',
            choices: ['yes', 'no'],
            description: 'Push images to registry after build'
        )
        choice(
            name: 'DEPLOY_AFTER_BUILD',
            choices: ['yes', 'no'],
            description: 'Deploy services after build'
        )
    }

    stages {
        stage('Validate Environment') {
            steps {
                script {
                    echo "Current branch: ${BRANCH_NAME}"
                    echo "Build environment: ${params.BUILD_ENVIRONMENT}"
                    
                    // For infrastructure repository, we allow any branch for development
                    // and only restrict production builds to main branch
                    if (params.BUILD_ENVIRONMENT == 'prod' && BRANCH_NAME != 'main') {
                        error "Production builds can only be triggered from main branch"
                    }
                    
                    // Verify required files exist
                    echo "Checking for ${BASE_COMPOSE}..."
                    if (!fileExists(BASE_COMPOSE)) {
                        error "Base docker-compose file ${BASE_COMPOSE} not found"
                    }
                    echo "Checking for ${ENV_COMPOSE}..."
                    if (!fileExists(ENV_COMPOSE)) {
                        error "Environment docker-compose file ${ENV_COMPOSE} not found"
                    }

                    // Get environment file from Jenkins credentials
                    def credentialId = "env-${params.BUILD_ENVIRONMENT}-file"
                    echo "Attempting to access credential: ${credentialId}"
                    try {
                        withCredentials([file(credentialsId: credentialId, variable: 'ENV_FILE_CONTENT')]) {
                            // Create the .env file in the workspace
                            sh """
                                cp \$ENV_FILE_CONTENT ${ENV_FILE}
                                chmod 600 ${ENV_FILE}
                            """
                            echo "Successfully created ${ENV_FILE} from credentials"
                        }
                    } catch (Exception e) {
                        error "Failed to access credential ${credentialId}: ${e.message}"
                    }
                }
            }
        }

        stage('Build Images') {
            steps {
                script {
                    def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                    def servicesToBuild = params.SERVICES_TO_BUILD == 'all' ? SERVICES.split(',') : [params.SERVICES_TO_BUILD]
                    def targetBranch = params.BUILD_ENVIRONMENT == 'prod' ? 'main' : 'dev'

                    servicesToBuild.each { service ->
                        echo "Building ${service} for ${params.BUILD_ENVIRONMENT} environment from ${targetBranch} branch"
                        
                        // Get repository URL based on service
                        def repoUrl
                        switch(service) {
                            case 'frontend':
                                repoUrl = FRONTEND_REPO
                                break
                            case 'backend':
                                repoUrl = BACKEND_REPO
                                break
                            case 'etl':
                                repoUrl = ETL_REPO
                                break
                            default:
                                error "Unknown service: ${service}"
                        }
                        
                        // Clone the service repository with the appropriate branch
                        sh """
                            rm -rf ../financial-tracker-${service}
                            git clone -b ${targetBranch} ${repoUrl} ../financial-tracker-${service}
                        """
                        
                        sh """
                            docker build -t ${DOCKER_REGISTRY}/${service}:${fullVersion} \
                                         -t ${DOCKER_REGISTRY}/${service}:${params.BUILD_ENVIRONMENT}-latest \
                                         ../financial-tracker-${service}
                        """
                    }
                }
            }
        }

        stage('Push Images') {
            when {
                expression { params.PUSH_IMAGES == 'yes' }
            }
            steps {
                script {
                    def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                    def servicesToPush = params.SERVICES_TO_BUILD == 'all' ? SERVICES.split(',') : [params.SERVICES_TO_BUILD]

                    withCredentials([usernamePassword(credentialsId: 'quay-credentials', usernameVariable: 'QUAY_USERNAME', passwordVariable: 'QUAY_PASSWORD')]) {
                        // Login to Docker registry using a more secure method
                        sh '''
                            echo "$QUAY_PASSWORD" | docker login quay.io --username "$QUAY_USERNAME" --password-stdin
                            
                            # Debug information
                            echo "Current user: $(whoami)"
                            echo "Docker config location: $HOME/.docker/config.json"
                            echo "Docker config permissions: $(ls -l $HOME/.docker/config.json)"
                            echo "Testing repository access..."
                            curl -s -u "$QUAY_USERNAME:$QUAY_PASSWORD" https://quay.io/api/v1/repository/johnkim1/frontend
                        '''
                        
                        servicesToPush.each { service ->
                            echo "Pushing ${service} for ${params.BUILD_ENVIRONMENT} environment"
                            try {
                                // First, try to create the repository if it doesn't exist
                                sh """
                                    # Try to create repository if it doesn't exist
                                    curl -s -X POST \
                                        -H "Content-Type: application/json" \
                                        -u "$QUAY_USERNAME:$QUAY_PASSWORD" \
                                        https://quay.io/api/v1/repository \
                                        -d '{"namespace": "johnkim1", "repository": "${service}", "visibility": "public", "description": "Financial Tracker ${service} service"}'
                                    
                                    # Wait a moment for repository creation to propagate
                                    sleep 5
                                    
                                    # Now try to push
                                    docker push ${DOCKER_REGISTRY}/${service}:${fullVersion}
                                    docker push ${DOCKER_REGISTRY}/${service}:${params.BUILD_ENVIRONMENT}-latest
                                """
                            } catch (Exception e) {
                                error """
                                    Failed to push ${service} images: ${e.message}
                                    Please verify:
                                    1. The repository exists in Quay.io
                                    2. The Jenkins bot user has write access to the repository
                                    3. The repository name matches exactly: ${DOCKER_REGISTRY}/${service}
                                    
                                    You can check repository access with:
                                    curl -s -u "$QUAY_USERNAME:$QUAY_PASSWORD" https://quay.io/api/v1/repository/johnkim1/${service}
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Deploy Services') {
            when {
                expression { params.DEPLOY_AFTER_BUILD == 'yes' }
            }
            steps {
                script {
                    echo "Deploying services for ${params.BUILD_ENVIRONMENT} environment"
                    
                    // Create network if it doesn't exist
                    sh """
                        if ! docker network ls | grep -q fintrack-network; then
                            docker network create fintrack-network
                        fi
                    """
                    
                    // Build compose command similar to start.sh
                    def composeCmd = "docker compose --env-file ${ENV_FILE} -f ${BASE_COMPOSE} -f ${ENV_COMPOSE}"
                    def servicesToDeploy = params.SERVICES_TO_BUILD == 'all' ? '' : params.SERVICES_TO_BUILD
                    
                    // Deploy using the compose command
                    sh """
                        ${composeCmd} up -d ${servicesToDeploy}
                    """

                    // Wait for services to be healthy
                    def startTime = System.currentTimeMillis()
                    def timeout = HEALTH_CHECK_TIMEOUT.toInteger() * 1000
                    def interval = HEALTH_CHECK_INTERVAL.toInteger() * 1000

                    while (System.currentTimeMillis() - startTime < timeout) {
                        def status = sh(
                            script: "${composeCmd} ps --format json",
                            returnStdout: true
                        ).trim()
                        
                        def allHealthy = true
                        def services = new groovy.json.JsonSlurper().parseText(status)
                        services.each { service ->
                            if (service.State != "running" || service.Health != "healthy") {
                                allHealthy = false
                            }
                        }
                        
                        if (allHealthy) {
                            echo "All services are healthy"
                            break
                        }
                        
                        echo "Waiting for services to be healthy..."
                        sleep(interval)
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                echo "Successfully built images for ${params.BUILD_ENVIRONMENT} environment"
                echo "Version: ${fullVersion}"
                if (params.PUSH_IMAGES == 'yes') {
                    echo "Images were pushed to registry"
                } else {
                    echo "Images were built but not pushed to registry"
                }
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    echo "Services were deployed using ${BASE_COMPOSE} and ${ENV_COMPOSE}"
                }
            }
        }
        failure {
            script {
                echo "Failed to build, push, or deploy services"
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    // Attempt to rollback on failure
                    def composeCmd = "docker compose --env-file ${ENV_FILE} -f ${BASE_COMPOSE} -f ${ENV_COMPOSE}"
                    def servicesToRollback = params.SERVICES_TO_BUILD == 'all' ? '' : params.SERVICES_TO_BUILD
                    
                    echo "Attempting to rollback deployment..."
                    sh """
                        ${composeCmd} down ${servicesToRollback}
                    """
                }
            }
        }
        always {
            // Cleanup
            script {
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    sh """
                        docker system prune -f
                    """
                }
            }
        }
    }
}