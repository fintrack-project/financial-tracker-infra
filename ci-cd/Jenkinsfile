pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'quay.io/johnkim1'
        BUILD_NUMBER = env.BUILD_NUMBER
        SERVICES = ['frontend', 'backend', 'etl']
        BRANCH_NAME = env.BRANCH_NAME
        BASE_COMPOSE = 'docker-compose.yml'
        ENV_COMPOSE = "docker-compose.${params.BUILD_ENVIRONMENT}.yml"
        ENV_FILE = ".env.${params.BUILD_ENVIRONMENT}"
        // Add timeout for health checks
        HEALTH_CHECK_TIMEOUT = '300' // 5 minutes
        HEALTH_CHECK_INTERVAL = '10' // 10 seconds
    }

    parameters {
        choice(
            name: 'BUILD_ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Select environment to build for'
        )
        string(
            name: 'VERSION_MAJOR',
            defaultValue: '1',
            description: 'Major version number'
        )
        string(
            name: 'VERSION_MINOR',
            defaultValue: '0',
            description: 'Minor version number'
        )
        string(
            name: 'VERSION_PATCH',
            defaultValue: '0',
            description: 'Patch version number'
        )
        choice(
            name: 'SERVICES_TO_BUILD',
            choices: ['all', 'frontend', 'backend', 'etl'],
            description: 'Select services to build'
        )
        choice(
            name: 'PUSH_IMAGES',
            choices: ['yes', 'no'],
            description: 'Push images to registry after build'
        )
        choice(
            name: 'DEPLOY_AFTER_BUILD',
            choices: ['yes', 'no'],
            description: 'Deploy services after build'
        )
    }

    stages {
        stage('Validate Environment') {
            steps {
                script {
                    // Only allow prod builds from main, dev from dev
                    if (params.BUILD_ENVIRONMENT == 'prod' && BRANCH_NAME != 'main') {
                        error "Production builds can only be triggered from main branch"
                    }
                    if (params.BUILD_ENVIRONMENT == 'dev' && BRANCH_NAME != 'dev') {
                        error "Development builds can only be triggered from dev branch"
                    }
                    
                    // Verify required files exist
                    if (!fileExists(BASE_COMPOSE)) {
                        error "Base docker-compose file ${BASE_COMPOSE} not found"
                    }
                    if (!fileExists(ENV_COMPOSE)) {
                        error "Environment docker-compose file ${ENV_COMPOSE} not found"
                    }
                    if (!fileExists(ENV_FILE)) {
                        error "Environment file ${ENV_FILE} not found"
                    }

                    // Validate required environment variables
                    def requiredVars = [
                        'DATABASE_NAME',
                        'POSTGRES_USER',
                        'POSTGRES_PASSWORD',
                        'DATABASE_INTERNAL_PORT',
                        'DATABASE_HOST_PORT'
                    ]
                    
                    def missingVars = []
                    requiredVars.each { var ->
                        if (!env[var]) {
                            missingVars.add(var)
                        }
                    }
                    
                    if (missingVars) {
                        error "Missing required environment variables: ${missingVars.join(', ')}"
                    }
                }
            }
        }

        stage('Build Images') {
            steps {
                script {
                    def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                    def servicesToBuild = params.SERVICES_TO_BUILD == 'all' ? SERVICES : [params.SERVICES_TO_BUILD]

                    servicesToBuild.each { service ->
                        echo "Building ${service} for ${params.BUILD_ENVIRONMENT} environment"
                        sh """
                            docker build -t ${DOCKER_REGISTRY}/${service}:${fullVersion} \
                                         -t ${DOCKER_REGISTRY}/${service}:${params.BUILD_ENVIRONMENT}-latest \
                                         ../financial-tracker-${service}
                        """
                    }
                }
            }
        }

        stage('Push Images') {
            when {
                expression { params.PUSH_IMAGES == 'yes' }
            }
            steps {
                script {
                    def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                    def servicesToPush = params.SERVICES_TO_BUILD == 'all' ? SERVICES : [params.SERVICES_TO_BUILD]

                    withCredentials([usernamePassword(credentialsId: 'quay-credentials', usernameVariable: 'QUAY_USERNAME', passwordVariable: 'QUAY_PASSWORD')]) {
                        sh """
                            echo $QUAY_PASSWORD | docker login quay.io --username $QUAY_USERNAME --password-stdin
                        """
                        servicesToPush.each { service ->
                            echo "Pushing ${service} for ${params.BUILD_ENVIRONMENT} environment"
                            sh """
                                docker push ${DOCKER_REGISTRY}/${service}:${fullVersion}
                                docker push ${DOCKER_REGISTRY}/${service}:${params.BUILD_ENVIRONMENT}-latest
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy Services') {
            when {
                expression { params.DEPLOY_AFTER_BUILD == 'yes' }
            }
            steps {
                script {
                    echo "Deploying services for ${params.BUILD_ENVIRONMENT} environment"
                    
                    // Create network if it doesn't exist
                    sh """
                        if ! docker network ls | grep -q fintrack-network; then
                            docker network create fintrack-network
                        fi
                    """
                    
                    // Build compose command similar to start.sh
                    def composeCmd = "docker compose --env-file ${ENV_FILE} -f ${BASE_COMPOSE} -f ${ENV_COMPOSE}"
                    def servicesToDeploy = params.SERVICES_TO_BUILD == 'all' ? '' : params.SERVICES_TO_BUILD
                    
                    // Deploy using the compose command
                    sh """
                        ${composeCmd} up -d ${servicesToDeploy}
                    """

                    // Wait for services to be healthy
                    def startTime = System.currentTimeMillis()
                    def timeout = HEALTH_CHECK_TIMEOUT.toInteger() * 1000
                    def interval = HEALTH_CHECK_INTERVAL.toInteger() * 1000

                    while (System.currentTimeMillis() - startTime < timeout) {
                        def status = sh(
                            script: "${composeCmd} ps --format json",
                            returnStdout: true
                        ).trim()
                        
                        def allHealthy = true
                        def services = new groovy.json.JsonSlurper().parseText(status)
                        services.each { service ->
                            if (service.State != "running" || service.Health != "healthy") {
                                allHealthy = false
                            }
                        }
                        
                        if (allHealthy) {
                            echo "All services are healthy"
                            break
                        }
                        
                        echo "Waiting for services to be healthy..."
                        sleep(interval)
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                def fullVersion = "${params.VERSION_MAJOR}.${params.VERSION_MINOR}.${params.VERSION_PATCH}-${params.BUILD_ENVIRONMENT}-${BUILD_NUMBER}"
                echo "Successfully built images for ${params.BUILD_ENVIRONMENT} environment"
                echo "Version: ${fullVersion}"
                if (params.PUSH_IMAGES == 'yes') {
                    echo "Images were pushed to registry"
                } else {
                    echo "Images were built but not pushed to registry"
                }
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    echo "Services were deployed using ${BASE_COMPOSE} and ${ENV_COMPOSE}"
                }
            }
        }
        failure {
            script {
                echo "Failed to build, push, or deploy services"
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    // Attempt to rollback on failure
                    def composeCmd = "docker compose --env-file ${ENV_FILE} -f ${BASE_COMPOSE} -f ${ENV_COMPOSE}"
                    def servicesToRollback = params.SERVICES_TO_BUILD == 'all' ? '' : params.SERVICES_TO_BUILD
                    
                    echo "Attempting to rollback deployment..."
                    sh """
                        ${composeCmd} down ${servicesToRollback}
                    """
                }
            }
        }
        always {
            // Cleanup
            script {
                if (params.DEPLOY_AFTER_BUILD == 'yes') {
                    sh """
                        docker system prune -f
                    """
                }
            }
        }
    }
}